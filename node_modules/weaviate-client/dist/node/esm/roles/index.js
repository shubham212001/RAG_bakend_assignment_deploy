import { Map } from './util.js';
const roles = (connection) => {
  return {
    listAll: () => connection.get('/authz/roles').then(Map.roles),
    ofCurrentUser: () => connection.get('/authz/users/own-roles').then(Map.roles),
    byName: (roleName) => connection.get(`/authz/roles/${roleName}`).then(Map.roleFromWeaviate),
    byUser: (user) => connection.get(`/authz/users/${user}/roles`).then(Map.roles),
    assignedUsers: (roleName) => connection.get(`/authz/roles/${roleName}/users`).then(Map.users),
    create: (roleName, permissions) => {
      const perms = Map.flattenPermissions(permissions).map(Map.permissionToWeaviate);
      return connection
        .postEmpty('/authz/roles', {
          name: roleName,
          permissions: perms,
        })
        .then(() => Map.roleFromWeaviate({ name: roleName, permissions: perms }));
    },
    delete: (roleName) => connection.delete(`/authz/roles/${roleName}`, null),
    exists: (roleName) =>
      connection
        .get(`/authz/roles/${roleName}`)
        .then(() => true)
        .catch(() => false),
    assignToUser: (roleNames, user) =>
      connection.postEmpty(`/authz/users/${user}/assign`, {
        roles: Array.isArray(roleNames) ? roleNames : [roleNames],
      }),
    revokeFromUser: (roleNames, user) =>
      connection.postEmpty(`/authz/users/${user}/revoke`, {
        roles: Array.isArray(roleNames) ? roleNames : [roleNames],
      }),
    addPermissions: (roleName, permissions) =>
      connection.postEmpty(`/authz/roles/${roleName}/add-permissions`, { permissions }),
    removePermissions: (roleName, permissions) =>
      connection.postEmpty(`/authz/roles/${roleName}/remove-permissions`, { permissions }),
    hasPermission: (roleName, permission) =>
      connection.postReturn(`/authz/roles/${roleName}/has-permission`, Map.permissionToWeaviate(permission)),
  };
};
export const permissions = {
  backup: (args) => {
    const collections = Array.isArray(args.collection) ? args.collection : [args.collection];
    return collections.flatMap((collection) => {
      const out = [];
      if (args.manage) {
        out.push({ collection, action: 'manage_backups' });
      }
      return out;
    });
  },
  cluster: (args) => {
    const out = [];
    if (args.read) {
      out.push({ action: 'read_cluster' });
    }
    return out;
  },
  collections: (args) => {
    const collections = Array.isArray(args.collection) ? args.collection : [args.collection];
    return collections.flatMap((collection) => {
      const out = [];
      if (args.create_collection) {
        out.push({ collection, action: 'create_collections' });
      }
      if (args.read_config) {
        out.push({ collection, action: 'read_collections' });
      }
      if (args.update_config) {
        out.push({ collection, action: 'update_collections' });
      }
      if (args.delete_collection) {
        out.push({ collection, action: 'delete_collections' });
      }
      return out;
    });
  },
  data: (args) => {
    const collections = Array.isArray(args.collection) ? args.collection : [args.collection];
    return collections.flatMap((collection) => {
      const out = [];
      if (args.create) {
        out.push({ collection, action: 'create_data' });
      }
      if (args.read) {
        out.push({ collection, action: 'read_data' });
      }
      if (args.update) {
        out.push({ collection, action: 'update_data' });
      }
      if (args.delete) {
        out.push({ collection, action: 'delete_data' });
      }
      return out;
    });
  },
  nodes: (args) => {
    const collections = Array.isArray(args.collection) ? args.collection : [args.collection];
    return collections.flatMap((collection) => {
      const out = [];
      if (args.read) {
        out.push({ collection, action: 'read_nodes', verbosity: args.verbosity || 'verbose' });
      }
      return out;
    });
  },
  roles: (args) => {
    const roles = Array.isArray(args.role) ? args.role : [args.role];
    return roles.flatMap((role) => {
      const out = [];
      if (args.read) {
        out.push({ role, action: 'read_roles' });
      }
      if (args.manage) {
        out.push({ role, action: 'manage_roles' });
      }
      return out;
    });
  },
};
export default roles;
